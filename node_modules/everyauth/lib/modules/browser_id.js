var everyModule = require('./everymodule')
  , rest = require('../restler')
  , url = require('url')
  , extractHostname = require('../utils').extractHostname;

var browser_id = module.exports =
  everyModule.submodule('browser_id')
  .configurable({
      verifierURL: 'External verifier, defaults to https://verifier.login.persona.org/verify',
      myHostname: 'e.g., http://localhost:3000 . Notice no trailing slash',
      alwaysDetectHostname: 'does not cache myHostname once. Instead, re-detect it on every request. Good for multiple subdomain architectures'
  })
  // .definit(function(){
  //   if(!this._verifierURL){
  //     this.verifierURL('https://verifier.login.persona.org/verify');
  //   }
  // })
  .verifierURL('https://verifier.login.persona.org/verify')
  .post('loginPath',
    'the URL to send the ajax call to log the user id')
    .step('verify')
      .description('verifies the users\'s assertion')
      .accepts('req res')
      .promises('userOrErrors')
    .step('interpretUserOrErrorsFromVerifier')
      .description('Pipes the output of the step `authenticate` into either the `user` or `errors` param')
      .accepts('userOrErrors')
      .promises('user errors')
    .step('authenticate') // must be defined by user and map the user object into one with an id propery
      .description('at this point we already know if the user is valid but we shuold get the user\'s id')
      .accepts('user req res')
      .promises('userOrErrors')
    .step('interpretUserOrErrors')
      .description('Pipes the output of the step `authenticate` into either the `user` or `errors` param')
      .accepts('userOrErrors')
      .promises('user errors')
    .step('getSession')
      .description('Retrieves the session of the incoming request and returns in')
      .accepts('req')
      .promises('session')
    .step('addToSession')
      .description('Adds the user to the session')
      .accepts('session user errors')
      .promises(null)
    .step('respondToLogin')
      .description('Execute a HTTP response for a successful or unsuccessful login')
      .accepts('req res user errors')
      .promises(null)

  .interpretUserOrErrorsFromVerifier( function (userOrErrors) {
    if (userOrErrors.status !== 'okay') {
      return [null, userOrErrors]; // We have an array of errors
    } else {
      delete userOrErrors.status;
      return [userOrErrors, []]; // We have a user
    }
  })

  .interpretUserOrErrors( function (userOrErrors) {
    if (Array.isArray(userOrErrors)) {
      return [null, userOrErrors]; // We have an array of errors
    } else {
      return [userOrErrors, []]; // We have a user
    }
  })

  .verify( function (req, res) {
    // Automatic hostname detection + assignment
    if (!this._myHostname || this._alwaysDetectHostname) {
      this.myHostname(extractHostname(req));
    }
    var promise = this.Promise();
    rest.post( this.verifierURL(), {
        // parser: rest.parsers.json,
        data: {
            assertion: req.body.assertion,
            audience: this.myHostname()
        }
    }).on('success', function (data, res) {
      promise.fulfill(data);
    }).on('error', function (data, res) {
      promise.fail([JSON.stringify(data)]);
    });
    return promise;
  })

  .getSession( function (req) {
    return req.session;
  })

  .addToSession( function (sess, user, errors) {
    var _auth = sess.auth || (sess.auth = {})
      , mod = _auth[this.name] || (_auth[this.name] = {});

    if (user){
      _auth.userId = user.id;
      mod.user = user;
    }
    _auth.loggedIn = !!user;
  })

  .respondToLogin(function(req, res, user, errors){
    if (user) {
      res.json({'status': 'okay', 'user': user});
    } else {
      res.json({'status':'error', 'errors': errors});
    }
  })

  .loginPath('/browser_id/login')